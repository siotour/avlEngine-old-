#pragma once
#ifndef AVL_MODEL_AGENT__
#define AVL_MODEL_AGENT__
/* Copyright 2012 Sheldon Bachstein
This file is part of the avl Library.

The avl Library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The avl Library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the avl Library.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
@file
<Autogenerated stub>
@author Sheldon Bachstein
@date Jun 26, 2012
*/

#include"..\..\..\utility\src\graphic\graphic.h"
#include"..\..\..\utility\src\sound effect\sound effect.h"
#include"..\reaction\reaction.h"
#include"..\action\action.h"
#include<map>
#include<memory>

namespace avl
{
namespace model
{

	/**

	@todo Consider new methods of passing Actions up the hierarchy.
	@todo Consider embedding a list of quads into this class for collision
	detection.
	*/
	class Agent
	{
	public:
		/** Basic constructor.
		*/
		Agent();

		/** Basic destructor.
		*/
		virtual ~Agent();

		/** Gets the render graphics which have been registered with this agent.
		@return The graphics registered with this agent.
		*/
		const utility::GraphicList& GetGraphics() const;

		/** Gets the sound effects which have been registered with this agent.
		@return The sound effects registered with this agent.
		*/
		const utility::SoundEffectList& GetSoundEffects() const;


		//const utility::QuadList& GetBoundingQuads() const;

		/** Gets the actions which have been enqueued by this agent.
		@return The actions which have been enqueued by this agent.
		*/
		ActionQueue& GetActions();

		/** React to a specific type of action.
		@note \a action will be forwarded to the reaction method registered
		for that specific Action subclass, if such a method has been registered.
		@param action The action to be reacted to.
		*/
		void React(const Action& action);

	protected:

		/** Register a method to 'react' to a specific type of action.
		@note Only one reaction may be registered for each action type.
		@param agent The Agent which reacts to the ActionType.
		@param reaction_method The method of \a agent which reacts to a specific
		type of action.
		*/
		template<class AgentType, class ActionType>
		void RegisterReaction(AgentType& agent, void (AgentType::*reaction_method)(const ActionType&));

		/** Register a graphic to be rendered to the screen.
		@param new_graphic The graphic to be rendered.
		*/
		void AddGraphic(const utility::Graphic* const new_graphic);

		/** Stop a graphic from being rendered to the scree.
		@param new_graphic The graphic which is to not be rendered any longer.
		*/
		void RemoveGraphic(const utility::Graphic* const graphic);

		/** Register a sound effect to be send to the sound engine.
		@param new_sound_effect The effect to be sent to the sound engine.
		*/
		void AddSoundEffect(utility::SoundEffect* const new_sound_effect);

		/** Register a sound effect to be send to the sound engine.
		@param new_sound_effect The effect to be sent to the sound engine.
		*/
		void RemoveSoundEffect(utility::SoundEffect* const sound_effect);

		/** Registers an action to be processed by the scene.
		@param action The new action to be processed.
		*/
		void EnqueueAction(const Action& action);

	private:
		/// Maps action types to their registered reaction methods.
		typedef std::map<reaction::TypeInfo, std::auto_ptr<reaction::Reaction>> Reactions;

		/// Used to forward specific action types to their registered reaction
		/// methods.
		Reactions reactions;

		/// Graphics registered to be sent to the renderer.
		utility::GraphicList graphic_list;

		/// Sound effects registered to be sent to the sound engine.
		utility::SoundEffectList sound_effect_list;

		/// Actions which are to be processed.
		ActionQueue action_queue;

	};



	// See method declaration for details.
	template<class AgentType, class ActionType>
	void Agent::RegisterReaction(AgentType& agent, void (AgentType::*reaction_method)(const ActionType&))
	{
		reactions.insert(std::make_pair(reaction::TypeInfo(typeid(ActionType)), std::auto_ptr<reaction::Reaction>(new reaction::DynamicReaction<AgentType, ActionType>(agent, reaction_method))));
	}



} // model
} // avl
#endif // AVL_MODEL_AGENT__
